#!/bin/bash
help(){
        cat <<EOF 
Usage: ts_network_backup  [OPTION(S)]
Create or restore network backup.

        -h              	prints this message
        -c ticket number 	create network backup
	-r backup directory 	restore network backup. The backup directory 
				should be in the format date-ticket_number.
	-d 			Data only. 
				Use of this option is strongly discouraged.
	-u 			Users and data only. 
				Use of this option is discouraged.
	-l log file		be careful not to use the same path for backing
				up and restoring, or the  log file may get 
				overwritten.
	-a /path/to/directory   Alternative directory to backup. implies -d
				Use this if you want to backup something
				other than the home directory.
				suggests the use of -A for restoring backups.
	-A /path/to/directory	Use this to restore the backup to somewhere
				other than the default (/home)
                                Can be used with or without -u or -d 
				suggests the later (required if needed). 

	-p /path/to/home	Use this if the home folder you want to
				backup is not in its usual place i.e. if you
				to backup an external drive rather than /home.
				You do not need to add home on the end but the
				script does not mind either way. 
				Can be used with or without -u or -d. 	
	
	Use this to create or restore network backups. By default it will attempt to restore users, their data and settings, and the progams installed on the machine. 


EOF
        exit 0
}


# config options
#group_file="groups"
#$password_file="passwords"
#shadow_file="shadows"
#dkpg_file="dpkg.out"
#sources_file="sources.list"

# source common functions
FUNCTIONS=ts_functions.sh # /path/to../
source $FUNCTIONS


# script specific functions

backup_users(){
	groupfile=$1 
	passwordfile=$2
	shadowfile=$3
	cat /etc/passwd| while read line ; do 
		user=$(echo $line | awk -F : '{print $1}')
		user_uid=$(echo $line | awk -F : '{print $3}')
		# if UID >999 then is normal (non-system) user
		if [[ $user_uid -gt 999 ]] ; then
			# unless user is a nobody :)
			if [[ ! $user == "nobody" ]]; then
				# gets lists of groups user belongs to
				echo "$user: $(id $user)" >>$groupfile
				echo $line >>$passwordfile
				# /etc/shadow contains the date of last password
				# change. Having this be older than the install
				# should not be a problem, but noting just in case
				grep -e ^$user: /etc/shadow >>$shadowfile
			fi
		fi
	done
}
restore_users(){
	# note that copying files back across is not sufficient 
	# need to extract values form files and added to new copies

	# read /home/password file or equivalent)
	cat $password_file| while read line ; do
 		user=$(echo $line | awk -F : '{print $1}')
		uid=$(echo $line | awk -F : '{print $3}')
		gid=$(echo $line | awk -F : '{print $4}')
		
                # delete matchinf lines in /etc/passwd 
                sed -i '/^$user:/ d' /etc/passwd
                # delete existing encypted password 
                sed -i '/^$user:/ d' /etc/shadow
		# delete matching lines/existing groups
                sed -i '/:$gid:/ d' /etc/group
		
		#copy relevant lines to /etc/passwd& shadow 
		echo $line >> /etc/passwd
		grep -e '/^$user:/' home/shadow >> /etc/shadow
                # create group for  user
                addgroup --gid $gid $user

		# read /home/group usermod to addusers to groups 	
		groups=$(grep -e "\<$user\>" $group_file | cut -f1 -d: -)
                for entry in $groups; do
                        if [[ $entry != $user ]]; then
 				if [[ ! $usergroups ]]; then
                                        usergroups=$entry
                                else
                                        usergroups="$entry,$usergroups"
                                fi
			fi
                done 
		if [[ ${#usergroups} -ne 0 ]] ; then
			usermod -a -G "$usergroups" $user 
		fi
	done
}

backup_sources(){
        if  !cp /etc/apt/sources.list $sources_file; then
                echo $?
        else
                echo 0
        fi
}
### TODO ###
restore_sources(){
}

backup_apt(){
	if  ! dpkg --get-selections > $dpkg_file ; then
		echo $?
	else
		echo 0
	fi 
}

restore_apt(){
        if  ! dpkg --set-selections < $dpkg_file ; then
                exit=$?
        else
                exit=0
        fi
	
	echo $exit
}

restore_packages(){
	if  ! apt-get -u dselect-upgrade  ; then
                exit=$?
        else
                exit=0
        fi

        echo $exit
}


backup_config(){
       if  ! tar -cvzf /home/etc_backup.tar.gz /etc/; then
                exit=$?
        else
                exit=0
        fi

        echo $exit

}


create_backup(){
	ticket="$1-$(date +%Y%m%d)"
	cpath=$2
	if [[ $3 ]]; then
		mylogfile=$3
		RSYNC=" -avzh $cpath tsbackup@tsbackup:/var/tsbackup/$ticket 2>>$mylogfile"
	else
		RSYNC="rsync -avzh $cpath tsbackup@tsbackup:/var/tsbackup/$ticket"
	fi	
	
	if ! $RSYNC; then
                exit=$?
        else
                exit=0
	fi
        
	echo $exit
}

restore_backup(){
	backupdir=$1
	backup_path=$2
	 if [[ $3 ]]; then
        	mylogfile=$3
        	RESTORE="rsync -avzh tsbackup@tsbackup:/var/tsbackup/$backupdir/ $backup_path/ 2>>$mylogfile"
	else
                RESTORE="rsync -avzh tsbackup@tsbackup:/var/tsbackup/$backupdir/ $backup_path/"
	fi

        if ! $RESTORE; then
 		exit=$?
        else
                exit=0
        fi

        echo $exit
}


### MAIN ###

while getopts ":hc:r:l:a:A:p:du" option; do
       case $option in
                h) help
                   exit 0
                ;;
                c) create_backup="true"
                   ticket_number="$OPTARG"
		;;
		r) restore_backup="true"
                   backup_dir="$OPTARG"
		;;
		d)
		   data_only="true"
                   no_apt="true"
                   no_user_passwords="true"
                   data_only="true"
                ;;
                u) no_apt="true"
                   users_and_data_only="true"
                ;;
                
		l) use_log="true"
		   log_file="$OPTARG"
		;;
		a) no_apt="true"
                   no_user_passwords="true"
                   data_only="true"
		   path="$OPTARG"
		;;
		A) rpath="$OPTARG"
		;;
		p) cut_path=$(echo "$OPTARG" |sed -r -e 's:/home/?$::' -e 's/\/*$//') 
		   path="${cut_path}/home"
		;;
		/?) help
                    exit 1
                ;;
        esac
	done

#sanity checks
if [[ $create_backup  &&  $restore_backup ]]; then 
	echo "Only one of the c or r options can be used";
	exit 2

elif [[ ! $create_backup && ! $restore_backup ]]; then 
        echo "One of the c or r options must  be used";
        exit 2

elif [[ $create_backup  &&  ! $ticket_number ]]; then 
        echo "You must supply a ticket number with the c option";
        exit 2

elif [[ $restore_backup && ! $backup_dir ]]; then
        echo "You must supply a backup directory with the r option";
        exit 2

elif [[ $data_only  &&  $users_and_data_only ]]; then
        echo "The u or d options are mutually exclusive";
        exit 2
else

	if [[ $(test_for_root) -ne 0 ]]; then
        	echo "Could not proceed!"
        	echo "Are you root?"
        	exit 2
	fi
fi
# TODO
        # add test if -A and not -d (-or u) then  warn and set ignore variable


# set paths etc
if [[ ! $path ]]; then 
	path="/home"
fi

if [[ ! $rpath ]]; then
        rpath="/home"
fi

group_file="/${path}/groups"
password_file="/${path}/passwords"
shadow_file="/${path}/shadows"
dkpg_file="/${path}/dpkg.out"


if [[ $create_backup ]]; then
	# unless no_apt is set back up record of packages installed
	if [[ ! $no_apt ]]; then
		if [[ $(check_file_write $dkpg_file) -ne 0 ]] ; then
			echo "Couldn't write to $dpkg_file. Check permissions?"
			exit 3
		fi
                if [[ $backup_sources -ne 0]] ; then
                        echo "Backing up sources.list failed!"
                        exit 3
                fi

		if [[ $backup_apt -ne 0]] ; then
			echo "Backing up package files list failed!"
			eho "dpkg --get-selections exited with error code $apt_backup" 
			exit 2
		fi
	fi 
	
	if [[ ! $no_user_passwords ]]; then
		# check we can wrtite to the backup files
		declare -a failarray
		for file in "$group_file" "$password_file" "$shadow_file"; do
			if [[ $(check_file_write "$file") -ne 0 ]]; then
				# if we cant write to file add to array		
				failarray=( ${failarray[@]-} $(echo "$file") )				fi			
		done
		# check length of failarray if >0 then something failed
		if [[ ${#failarray[@]} -ne 0 ]]; then
			echo -n "error writing to "
			for name in ${failarray[@]}; do
				echo -n "$name"
			done
			exit 3 
		fi 
		# difficult to check except by checking write  (as above)
		backup_users
	fi
	if [[ $(backup_config) -ne 0 ]]; then
		echo "Could not backup /etc"
		exit $config_check
	fi
	if [[ $use_log ]]; then	
		if [[ ! $log_file ]]; then
			log_file="rsync.log"
		fi
		if [[ $(check_file_write "$log_file") -ne 0 ]]; then
			echo "Couldn't write to $log_file"
			exit 3
		fi
		backup_check=$(create_backup $ticket_number $path $log_file)
	else
		backup_check=$(create_backup $ticket_number $path)
	fi
	if [[ backup_check -ne 0 ]]; then
		echo "Could not backup data!!!"
		if [[ $log_file ]]; then
			echo "error messages are recorded in $log_file"
		fi
		exit $backup_check
	fi


elif [[ $restore_backup ]] ; then

        # not the same as backup_password_files
        # does its own error handling
        backup_passwords

        if [[ $use_log ]]; then
                if [[ ! $log_file ]]; then
                        log_file="restore.log"
		fi
 		if [[ $(check_file_write "$log_file") -ne 0 ]]; then
 			echo "Couldn't write to $log_file"
 			exit 3
		fi
                restore_check=$(restore_backup $ticket_number $rpath $log_file)
        else
                restore_check=$(restore_backup $ticket_number $rpath)
        fi
        if [[ restore_check -ne 0 ]]; then
                echo "Could not restore backup!!!"
                if [[ $log_file ]]; then
                        echo "error messages are recorded in $log_file"
                fi
                exit restore_check
        fi


	###TODO###
	#if [[ ! $no_apt ]]; then
	#if [[ ! $no_user_passwords ]]; then
	# add test [if -A and not -d (-or u) then] do the user etc/apt files
	# exist? no? warn / ignore
else	
	# Should never get here as we should have caught it 
	# at the top of the sanity check
	echo "You should never see this message. If you are reading it now this script is broken."
fi 
