#!/bin/bash
help(){
        cat <<EOF 
Usage: ts_network_backup  [OPTION(S)]
Create or restore network backup.

        -h              	prints this message
        -c ticket number 	create network backup
	-r backup directory 	restore network backup. The backup directory 
				should be in the format date-ticket_number.
	-d 			Data only. 
				Use of this option is strongly discouraged.
	-u 			Users and data only. 
				Use of this option is discouraged.
	-l log file		be careful not to use the same path for backing
				up and restoring, or the  log file may get 
				overwritten.
	-a /path/to/directory   Alternative directory to backup. implies -d
				Use this if you want to backup something
				other than the home directory.
				suggests the use of -A for restoring backups.
	-A /path/to/directory	Use this to restore the backup to somewhere
				other than the default (/home)
                                Can be used with or without -u or -d 
				suggests the later (required if needed). 

	-p /path/to/home	Use this if the home folder you want to
				backup is not in its usual place i.e. if you
				to backup an external drive rather than /home.
				You do not need to add home on the end but the
				script does not mind either way. 
				Can be used with or without -u or -d. 	
	
	Use this to create or restore network backups. By default it will attempt to restore users, their data and settings, and the progams installed on the machine. 


EOF
        exit 0
}


# config options
#group_file="groups"
#$password_file="passwords"
#shadow_file="shadows"
#dkpg_file="dpkg.out"
#sources_file="sources.list"

# source common functions
FUNCTIONS=ts_functions.sh # /path/to../
source $FUNCTIONS


# script specific functions
backup_users_test(){
	groupfile=$1 
	passwordfile=$2
	shadowfile=$3
		# check we can wrtite to the backup files
	declare -a failarray
	for file in "$group_file" "$password_file" "$shadow_file"; do
		if [[ $(check_file_write "${file}") -ne 0 ]]; then
			# if we cant write to file add to array		
			failarray=( ${failarray[@]-} $(echo "$file") )				fi			
	done
	# check length of failarray if >0 then something failed
	if [[ ${#failarray[@]} -ne 0 ]]; then
		echo -n "error writing to "
		for name in ${failarray[@]}; do
			echo -n "$name"
		done
		return 3 
	fi 	
	return 0
}


backup_users(){
	groupfile=$1 
	passwordfile=$2
	shadowfile=$3
	cat /etc/passwd| while read line ; do 
		user=$(echo $line | awk -F : '{print $1}')
		user_uid=$(echo $line | awk -F : '{print $3}')
		# if UID >999 then is normal (non-system) user
		if [[ $user_uid -gt 999 ]] ; then
			# unless user is a nobody :)
			if [[ ! $user == "nobody" ]]; then
				# gets lists of groups user belongs to
				echo "$user: $(id $user)" >>$groupfile
				echo $line >>$passwordfile
				# /etc/shadow contains the date of last password
				# change. Having this be older than the install
				# should not be a problem, but noting just in case
				grep -e ^$user: /etc/shadow >>$shadowfile
				userlist="$userlist $user"
			fi
		fi
	done
echo "backed up passwords for $userlist"
}

restore_users(){
	# note that copying files back across is not sufficient 
	# need to extract values form files and added to new copies

	# read /home/password file or equivalent)
	cat $password_file| while read line ; do
 		user=$(echo $line | awk -F : '{print $1}')
		uid=$(echo $line | awk -F : '{print $3}')
		gid=$(echo $line | awk -F : '{print $4}')
		
                # delete matchinf lines in /etc/passwd 
                sed -i '/^$user:/ d' /etc/passwd
                # delete existing encypted password 
                sed -i '/^$user:/ d' /etc/shadow
		# delete matching lines/existing groups
                sed -i '/:$gid:/ d' /etc/group
		
		#copy relevant lines to /etc/passwd& shadow 
		echo $line >> /etc/passwd
		grep -e '/^$user:/' home/shadow >> /etc/shadow
                # create group for  user
                addgroup --gid $gid $user

		# read /home/group usermod to addusers to groups 	
		groups=$(grep -e "\<$user\>" $group_file | cut -f1 -d: -)
                for entry in $groups; do
                        if [[ $entry != $user ]]; then
 				if [[ ! $usergroups ]]; then
                                        usergroups=$entry
                                else
                                        usergroups="$entry,$usergroups"
                                fi
			fi
                done 
		if [[ ${#usergroups} -ne 0 ]] ; then
			usermod -a -G "$usergroups" $user 
		fi
	done
}

backup_sources(){
        cp /etc/apt/sources.list $sources_file 2>&1
        local retval=$?
        exit $retval
}
### TODO ###
restore_sources(){
}

backup_apt(){
	dpkg --get-selections > $dpkg_file   2>&1
	local retval=$?
        exit $retval
}

restore_apt(){
        dpkg --set-selections < $dpkg_file  2>&1
	local retval=$?
        exit $retval
}

restore_packages(){
	apt-get -u dselect-upgrade   2>&1
        local retval=$?
        exit $retval
}

backup_config(){
        tar -czf ${path}/etc_backup.tar.gz /etc/  2>&1
        local retval=$?
        exit $retval
}



create_backup(){
	ticket="$1-$(date +%Y%m%d)"
	cpath=$2
	if [[ $3 ]]; then
		mylogfile=$3
		RSYNC=" -avzh $cpath tsbackup@tsbackup:/var/tsbackup/$ticket 2>>$mylogfile"
	else
		RSYNC="rsync -avzh $cpath tsbackup@tsbackup:/var/tsbackup/$ticket"
	fi	
	
	if ! $RSYNC; then
                exit=$?
        else
                exit=0
	fi
        
	echo $exit
}

restore_backup(){
	backupdir=$1
	backup_path=$2
	 if [[ $3 ]]; then
        	mylogfile=$3
        	RESTORE="rsync -avh tsbackup@tsbackup:/var/tsbackup/$backupdir/ $backup_path/ 2>>$mylogfile"
	else
                RESTORE="rsync -avh tsbackup@tsbackup:/var/tsbackup/$backupdir/ $backup_path/"
	fi

        if ! $RESTORE; then
 		exit=$?
        else
                exit=0
        fi

        echo $exit
}


### MAIN ###

while getopts ":hc:r:l:a:A:p:du" option; do
       case $option in
                h) help
                   exit 0
                ;;
                c) create_backup="true"
                   ticket_number="$OPTARG"
		;;
		r) restore_backup="true"
                   backup_dir="$OPTARG"
		;;
		d)
		   data_only="true"
                   no_apt="true"
                   no_user_passwords="true"
                   data_only="true"
                ;;
                u) no_apt="true"
                   users_and_data_only="true"
                ;;
                
		l) use_log="true"
		   log_file="$OPTARG"
		;;
		a) no_apt="true"
                   no_user_passwords="true"
                   data_only="true"
		   path="$OPTARG"
		;;
		A) rpath="$OPTARG"
		;;
		p) cut_path=$(echo "$OPTARG" |sed -r -e 's:/home/?$::' -e 's/\/*$//') 
		   path="${cut_path}/home"
		;;
		/?) help
                    exit 1
                ;;
        esac
	done

#sanity checks
if [[ $create_backup  &&  $restore_backup ]]; then 
	echo "Only one of the c or r options can be used";
	exit 2

elif [[ ! $create_backup && ! $restore_backup ]]; then 
        echo "One of the c or r options must  be used";
        exit 2

elif [[ $create_backup  &&  ! $ticket_number ]]; then 
        echo "You must supply a ticket number with the c option";
        exit 2

elif [[ $restore_backup && ! $backup_dir ]]; then
        echo "You must supply a backup directory with the r option";
        exit 2

elif [[ $data_only  &&  $users_and_data_only ]]; then
        echo "The u or d options are mutually exclusive";
        exit 2
else

	if [[ $(test_for_root) -ne 0 ]]; then
        	echo "Could not proceed!"
        	echo "Are you root?"
        	exit 2
	fi
fi
# TODO
        # add test if -A and not -d (-or u) then  warn and set ignore variable


# set paths etc
if [[ ! $path ]]; then 
	path="/home"
fi

if [[ ! $rpath ]]; then
        rpath="/home"
fi

if [[ $use_log ]]; then	
	if [[ ! $log_file ]]; then
		log_file="rsync.log"
	fi
	if [[ $(check_file_write "$log_file") -ne 0 ]]; then
		echo "Couldn't write to $log_file"
		exit 3
	fi
fi



group_file="/${path}/groups"
password_file="/${path}/passwords"
shadow_file="/${path}/shadows"
dkpg_file="/${path}/dpkg.out"


if [[ $create_backup ]]; then

	# unless no_apt is set back up record of packages installed
	if [[ ! $no_apt ]]; then
		if [[ $(check_file_write $dkpg_file) -ne 0 ]] ; then
			write_msg "Couldn't write to $dpkg_file Check permissions?" $log_file
			exit 3
		fi
                backup_sources
		if [[ $? -ne 0]] ; then
                        write_msg "Backing up sources.list failed!" $log_file
                        exit 3
                fi
		aptbackup=$(backup_apt)
		aptbackup_return=$?
		if [[ $aptbackup_return -ne 0]] ; then

			write_msg "$aptbackup" $log_file
			write_msg "Backing up package files list failed!" $log_file
			write_msg "dpkg --get-selections exited with error code $aptbackup_return" $log_file 
			exit 3
		fi
	fi 
	
	if [[ ! $no_user_passwords ]]; then
		backup_user_check=$(backup_user_test $group_file $password_file $shadow_file)
		if [[ $? -ne 0 ]]; then
			write_msg $backup_user_check
			exit 3
		else
			  
		user_backup=$(backup_users $group_file $password_file $shadow_file)
		write_msg $user_backup $log_file
	fi

	if [[ $(backup_config $log_file) -ne 0 ]]; then
		write_msg "Could not backup /etc" $log_file
		exit $config_check
	fi

	if [[ $(create_backup $ticket_number $path $log_file) -ne 0 ]]; then
		echo "Could not backup data!!!"
		if [[ $log_file ]]; then
			echo "error messages are recorded in $log_file"
		fi
		exit $backup_check
	fi


elif [[ $restore_backup ]] ; then

        # not the same as backup_password_files
        backup_passwords_check=$(backup_passwords)
	if [[$? -ne 0 ]]; then
		echo $backup_passwords_check
		echo "failed to backup password files ..exiting"
		exit 2
	fi

        if [[ $use_log ]]; then
                if [[ ! $log_file ]]; then
                        log_file="restore.log"
		fi
 		if [[ $(check_file_write "$log_file") -ne 0 ]]; then
 			echo "Couldn't write to $log_file"
 			exit 3
		fi
	fi
        
	restore_check=$(restore_backup $ticket_number $rpath $log_file)
        if [[ restore_check -ne 0 ]]; then
                echo "Could not restore backup!!!"
                if [[ $log_file ]]; then
                        echo "error messages are recorded in $log_file"
                fi
                exit restore_check
        fi


	###TODO###
	#if [[ ! $no_apt ]]; then
	#if [[ ! $no_user_passwords ]]; then
	# add test [if -A and not -d (-or u) then] do the user etc/apt files
	# exist? no? warn / ignore
	# if user had multiverse enabled
	grep multiverse $sources_file
	multiverse_test=$?
	# if user had partner software enabled
	grep partner $sources_file
	partner_test=$?
	codename=$(lsb_release -c |  awk '{print $2}') # lucid etc
	if [[ $multiverse_test -eq 0 ]]; then
	#identify and comment out  relevant lines 
		multiverse_check=$(restore_multiverse $codename)
		if [[multiverse_check
	fi
}


else	
	# Should never get here as we should have caught it 
	# at the top of the sanity check
	echo "You should never see this message. If you are reading it now this script is broken."
fi 
