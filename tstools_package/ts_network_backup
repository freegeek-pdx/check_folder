#!/bin/bash
help(){
        cat <<EOF 
Usage: ts_network_backup  [OPTION(S)]
Create or restore network backup.

        -h              	prints this message
        -c ticket number 	create network backup
	-r backup directory 	restore network backup. The backup directory 
				should be in the format date-ticket_number.
	-d 			Data only. 
				Use of this option is strongly discouraged.
	-u 			Users and data only. 
				Use of this option is discouraged.
	-l log file		be careful not to use the same path for backing
				up and restoring, or the  log file may get 
				overwritten.
	-a /path/to/directory   Alternative directory to backup. implies -d
				Use this if you want to backup something
				other than the home directory.
				suggests the use of -A for restoring backups.
	-A /path/to/directory	Use this to restore the backup to somewhere
				other than the default (/home)
                                Can be used with or without -u or -d 
				suggests the later (required if needed). 

	-p /path/to/home	Use this if the home folder you want to
				backup is not in its usual place i.e. if you
				to backup an external drive rather than /home.
				You do not need to add home on the end but the
				script does not mind either way. 
				Can be used with or without -u or -d. 	
	
	Use this to create or restore network backups. By default it will attempt to restore users, their data and settings, and the progams installed on the machine. 


EOF
        exit 0
}


# source common functions
MAIN_FUNCTIONS=ts_functions.sh # /path/to../
NB_FUNCTIONS=ts_network_backup_functions.sh
source $MAIN_FUNCTIONS
source $NB_FUNCTIONS

### MAIN ###

while getopts ":hc:r:l:a:A:p:du" option; do
       case $option in
                h) help
                   exit 0
                ;;
                c) create_backup="true"
                   ticket_number="$OPTARG"
		;;
		r) restore_backup="true"
                   backup_dir="$OPTARG"
		;;
		d)
		   data_only="true"
                   no_apt="true"
                   no_user_passwords="true"
                   data_only="true"
                ;;
                u) no_apt="true"
                   users_and_data_only="true"
                ;;
                
		l) use_log="true"
		   log_file="$OPTARG"
		;;
		a) no_apt="true"
                   no_user_passwords="true"
                   data_only="true"
		   path="$OPTARG"
		;;
		A) rpath="$OPTARG"
		;;
		p) cut_path=$(echo "$OPTARG" |sed -r -e 's:/home/?$::' -e 's/\/*$//') 
		   path="${cut_path}/home"
		;;
		/?) help
                    exit 1
                ;;
        esac
	done

#sanity checks
if [[ $create_backup  &&  $restore_backup ]]; then 
	echo "Only one of the c or r options can be used";
	exit 3

elif [[ ! $create_backup && ! $restore_backup ]]; then 
        echo "One of the c or r options must  be used";
        exit 3

elif [[ $create_backup  &&  ! $ticket_number ]]; then 
        echo "You must supply a ticket number with the c option";
        exit 3

elif [[ $restore_backup && ! $backup_dir ]]; then
        echo "You must supply a backup directory with the r option";
        exit 3

elif [[ $data_only  &&  $users_and_data_only ]]; then
        echo "The u or d options are mutually exclusive";
        exit 3
else

        test_for_root
	if (( $? != 0 )); then
		echo "Could not proceed!"
        	echo "Are you root?"
        	exit 3
	fi
fi
# TODO
        # add test if -A and not -d (-or u) then  warn and set ignore variable


# set paths etc
if [[ ! $path ]]; then 
	path="/home"
fi

if [[ ! $rpath ]]; then
        rpath="/home"
fi

if [[ $use_log ]]; then	
	if [[ ! $log_file ]]; then
		log_file="rsync.log"
	fi
	if [[ $(check_file_write "$log_file") -ne 0 ]]; then
		echo "Couldn't write to $log_file"
		exit 3
	fi
fi


#CONFIG
group_file="/${path}/groups"
password_file="/${path}/passwords"
shadow_file="/${path}/shadows"
dkpg_file="/${path}/dpkg.out"


if [[ $create_backup ]]; then

	# unless no_apt is set back up record of packages installed
	if [[ ! $no_apt ]]; then
		if [[ $(check_file_write $dkpg_file) -ne 0 ]] ; then
			write_msg "Couldn't write to $dpkg_file Check permissions?" $log_file
			exit 3
		fi
                backup_sources
		if (( $? != 0 )) ; then
                        write_msg "Backing up sources.list failed!" $log_file
                        exit 3
                fi
		aptbackup=$(backup_apt)
		aptbackup_return=$?
		if (( $aptbackup_return != 0 )) ; then

			write_msg "$aptbackup" $log_file
			write_msg "Backing up package files list failed!" $log_file
			write_msg "dpkg --get-selections exited with error code $aptbackup_return" $log_file 
			exit 3
		fi
	fi 
	
	if [[ ! $no_user_passwords ]]; then
		backup_user_check=$(backup_user_test $group_file $password_file $shadow_file)
		if (( $? -ne 0 )); then
			write_msg $backup_user_check
			exit 3
		else
			  
		user_backup=$(backup_users $group_file $password_file $shadow_file)
		if (( $? != 0 ))then
			write_msg $user_backup $log_file
			exit 3
		else
			write_msg $user_backup $log_file
		fi
	fi
	backup_config
	config_check=$?
	if (( $config_check !=  0 )); then
		write_msg "Could not backup /etc" $log_file
		exit $config_check
	fi

	make_backup="$(create_backup $ticket_number $path)"
	backup_check=$? 
	if (($backup_check != 0)); then
		write_msg "$make_backup" $log_file
		exit $backup_check
	else
		write_msg "$make_backup" $log_file
	fi


elif [[ $restore_backup ]] ; then

        # not the same as backup_password_files
        backup_passwords_check=$(backup_passwords)
	if (( $? != 0)); then
		write_msg "$backup_passwords_check"$ log_file
		write_msg "failed to backup password files ..exiting" $log_file
		exit 3
	fi

        
	restorebackup=$(restore_backup $ticket_number $rpath)
	restore_check=$?
	write_msg $restorebackup
        if (( $restore_check != 0 )); then
                write_msg "Could not restore backup!!!"
                exit $restore_check
        fi


	###TODO###
	if [[ ! $no_apt ]]; then
		# add test [if -A and not -d (-or u) then] do the user etc/apt files
		# exist? no? warn / ignore
		# if user had multiverse enabled
		grep multiverse $sources_file
		multiverse_test=$?
		# if user had partner software enabled
		grep partner $sources_file
		partner_test=$?
		codename=$(lsb_release -c |  awk '{print $2}') # lucid etc
		if (( $multiverse_test == 0 )); then
		#identify and comment out  relevant lines 
			restore_multiverse $codename
			if (( $? != 0 )); then
				write_msg "unable to add multiverse to sources list" $log_file
			fi
		fi
		if (( $partner_test == 0 )); then
			 #identify and comment out  relevant lines 
			restore_multiverse $codename
			if (( $? != 0 )); then
				write_msg "unable to add Canonical partners to sources list" $log_file
			fi
        	fi
	fi
	
	###TODO###
	#        #if [[ ! $no_user_passwords ]]; then
 
else	
	# Should never get here as we should have caught it 
	# at the top of the sanity check
	echo "You should never see this message. If you are reading it now this script is broken."
fi 
