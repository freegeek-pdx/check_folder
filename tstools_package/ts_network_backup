#!/bin/bash

#!/bin/bash
help(){
        cat <<EOF 
Usage: ts_network_backup  [OPTION(S)]
Create or restore network backup.

        -h              	prints this message
	-l log file		be careful not to use the same path for backing
				up and restoring, or the  log file may get 
				overwritten.
        -c ticket number 	create network backup
	-r backup directory 	restore network backup. The backup directory 
				should be in the format date-ticket_number.
	-d 			Data only. 
				Use of this option is strongly discouraged.
	-u 			Users and data only. 
				Use of this option is discouraged.		
	Use this to create or restore network backups. By default it will attempt to restore users, their data and settings, and the progams installed on the machine. 
EOF
        exit 0
}


# config options
group_file="/home/groups"
password_file="/home/passwords"
shadow_file="/home/shadows"
dkpg_file="/home/dpkg.out"

# source common functions
FUNCTIONS=ts_functions.sh # /path/to../
source $FUNCTIONS


# script specific functions

backup_paswords(){
	groupfile=$1 
	passwordfile=$2
	shadowfile=$3
	cat /etc/passwd| while read line ; do 
		user=$(echo $line | awk -F : '{print $1}')
		user_uid=$(echo $line | awk -F : '{print $3}')
		# if UID >999 then is normal (non-system) user
		if [[ $user_uid -gt 999 ]] ; then
			# unless user is a nobody :)
			if [[ ! $user == "nobody" ]]; then
				# gets lists of groups user belongs to
				echo "$user: $(id $user)" >>$groupfile
				echo $line >>$passwordfile
				# /etc/shadow contains the date of last password
				# change. Having this be older than the install
				# should not be a problem, but noting just in case
				grep -e ^$user: /etc/shadow >>$shadowfile
			fi
		fi
	done
}

restore_passwords(){
	# note that copying files back across is not sufficient 
	# need to extract values form files and added to new copies
	
	# Backup existing files
	isotime=$(date +%Y%m%d%H%M%S)
	cp /etc/passwd /etc/passwd.freegeek_ts_bak.$isotime
	cp /etc/group /etc/group.freegeek_ts_bak.$isotime
	cp /etc/shadow /etc/shadow.freegeek_ts_bak.$isotime

	# read /home/password file
	cat $password_file| while read line ; do
 		user=$(echo $line | awk -F : '{print $1}')
		uid=$(echo $line | awk -F : '{print $3}')
		gid=$(echo $line | awk -F : '{print $4}')
		
                # delete matchinf lines in /etc/passwd 
                sed -i '/^$user:/ d' /etc/passwd
                # delete existing encypted password 
                sed -i '/^$user:/ d' /etc/shadow
		# delete matching lines/existing groups
                sed -i '/:$gid:/ d' /etc/group
		
		#copy relevant lines to /etc/passwd& shadow 
		echo $line >> /etc/passwd
		grep -e '/^$user:/' home/shadow >> /etc/shadow
                # create group for  user
                addgroup --gid $gid $user

		# read /home/group usermod to addusers to groups 	
		groups=$(grep -e '/^$user:/' $group_file | cut -f2- -d, -)
		#number_of_groups=$(echo $groups  | awk -F, '{print NF}')
		IFS=,
		for entry in $groups; do
			group=$(echo $entry | cut -f2 -d'(' - | sed 's/)//')
			usermod -a -G $group $user
		done
	done
}


backup_apt(){
	if  ! dpkg --get-selections > $dpkg_file ; then
		echo $?
	else
		echo 0
	fi 
}

restore_apt(){
        if  ! dpkg --set-selections < $dpkg_file ; then
                exit=$?
        else
                exit=0
        fi
	
	echo $exit
}

restore_packages(){
	if  ! apt-get -u dselect-upgrade  ; then
                exit=$?
        else
                exit=0
        fi

        echo $exit
}


backup_config(){
       if  ! tar -cvzf /home/etc_backup.tar.gz /etc/; then
                exit=$?
        else
                exit=0
        fi

        echo $exit

}

check_file_write(){
	file=$1
	
	if ! touch $file; then
		exit=$?
	else
		exit=0
	fi

	echo $exit
}

create_backup(){
	ticket="$1-$(date +%Y%m%d)"

	if [[ $2 ]]; then
		mylogfile=$2
		RSYNC=" -avzh home/ tsbackup@tsbackup:/var/tsbackup/$ticket 2>>$mylogfile"
	else
		RSYNC="rsync -avzh home/ tsbackup@tsbackup:/var/tsbackup/$ticket"
	fi	
	
	if ! $RSYNC; then
                exit=$?
        else
                exit=0
	fi
        
	echo $exit
}

restore_backup(){
	backupdir=$1
	 if [[ $2 ]]; then
        	mylogfile=$2
        	RESTORE="rsync -avzh tsbackup@tsbackup:/var/tsbackup/$backupdir/ home/ 2>>$mylogfile"
	else
                RESTORE="rsync -avzh tsbackup@tsbackup:/var/tsbackup/$backupdir/ home/"
	fi

        if ! $RESTORE; then
 		exit=$?
        else
                exit=0
        fi

        echo $exit
}


### MAIN ###

while getopts ":hl:c:r:du" option; do
       case $option in
                h) help
                   exit 0
                ;;
                c) create_backup="true"
                   ticket_number=$OPTARG
		;;
		l) use_log="true"
		   log_file=$OPTARG
		r) restore_backup="true"
                   backup_dir=$OPTARG
		;;
		d) no_apt="true"
		   no_user_passwords="true"
		   data_only="true"
		;;
		u) no_apt="true"
		   users_and_data_only="true"
		;;
                /?) help
                    exit 1
                ;;
        esac
	done

#sanity checks
if [[ $create_backup  &&  $restore_backup ]]; then 
	echo "Only one of the c or r options can be used";
	exit 2
fi


if [[ ! $create_backup && ! $restore_backup ]]; then 
        echo "One of the c or r options must  be used";
        exit 2
fi

if [[ $create_backup  &&  ! $ticket_number ]]; then 
        echo "You must supply a ticket number with the c option";
        exit 2
fi

if [[ $restore_backup && ! $backup_dir ]]; then
        echo "You must supply a backup directory with the r option";
        exit 2
fi
if [[ $data_only  &&  $users_and_data_only ]]; then
        echo "The u or d options are mutually exclusive";
        exit 2
fi
root_test=$(test_for_root)
if [[ $root_test -ne 0 ]]; then
        echo "Could not proceed!"
        echo "Are you root?"
        exit 2
fi

# 


if [[ $create_backup ]]; then
	# unless no_apt is set back up record of packages installed
	if [[ ! $no_apt ]]; then
		apt_write=$(check_file_write $dkpg_file)
		if [[ $apt_write -ne 0 ]] ; then
			echo "Couldn't write to $dpkg_file. Check permissions?"
			exit 3
		fi
		apt_backup=$(backup_apt)
		if [[ $apt_backup -ne 0]] ; then
			echo "Backing up package files list failed!"
			eho "dpkg --get-selections exited with error code $apt_backup" 
			exit 2
		fi
	fi 
	
	if [[ ! $no_user_passwords ]]; then
		# check we can wrtite to the backup files
		declare -a failarray
		for file in "$group_file" "$password_file" "$shadow_file"; do
			writecheck=$(check_file_write "$file")
			if [[ writecheck -ne 0 ]]; then
				# if we cant write to file add to array		
				failarray=( ${failarray[@]-} $(echo "$file") )				fi			
		done
		# check length of failarray if >0 then something failed
		if [[ ${#failarray[@]} -ne 0 ]]; then
			echo -n "error writing to "
			for name in ${failarray[@]}; do
				echo -n "$name"
			done
			exit 3 
		if 
		# difficult to check except by checking write  (as above)
		backup_paswords
	fi
	config_check=$(backup_config)
	if [[ config_check -ne 0 ]]; then
		echo "Could not backup /etc"
		exit $config_check
	fi 
	backup_check=$(create_backup)
	if [[ backup_check -ne 0 ]]; then
		echo "Could not backup data!!!"
		exit $backup_check
	fi
fi
